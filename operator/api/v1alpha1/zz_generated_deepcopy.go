//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by hand (controller-gen equivalent). DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Ensure interface compliance.
var _ runtime.Object = &BrowserlessPool{}
var _ runtime.Object = &BrowserlessPoolList{}
var _ runtime.Object = &BrowserSession{}
var _ runtime.Object = &BrowserSessionList{}
var _ runtime.Object = &AutomationTask{}
var _ runtime.Object = &AutomationTaskList{}
var _ runtime.Object = &TaskRecord{}
var _ runtime.Object = &TaskRecordList{}

// ============================================================================
// BrowserlessPool
// ============================================================================

func (in *BrowserlessPool) DeepCopyInto(out *BrowserlessPool) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *BrowserlessPool) DeepCopy() *BrowserlessPool {
	if in == nil { return nil }
	out := new(BrowserlessPool)
	in.DeepCopyInto(out)
	return out
}

func (in *BrowserlessPool) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *BrowserlessPoolList) DeepCopyInto(out *BrowserlessPoolList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]BrowserlessPool, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *BrowserlessPoolList) DeepCopy() *BrowserlessPoolList {
	if in == nil { return nil }
	out := new(BrowserlessPoolList)
	in.DeepCopyInto(out)
	return out
}

func (in *BrowserlessPoolList) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *BrowserlessPoolSpec) DeepCopyInto(out *BrowserlessPoolSpec) {
	*out = *in
	if in.TokenSecretRef != nil {
		out.TokenSecretRef = new(SecretKeyRef)
		*out.TokenSecretRef = *in.TokenSecretRef
	}
	if in.Resources != nil {
		out.Resources = new(ResourceRequirements)
		*out.Resources = *in.Resources
	}
	if in.HealthCheck != nil {
		out.HealthCheck = new(HealthCheckConfig)
		*out.HealthCheck = *in.HealthCheck
	}
}

func (in *BrowserlessPoolStatus) DeepCopyInto(out *BrowserlessPoolStatus) {
	*out = *in
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		for i := range in.Conditions {
			in.Conditions[i].DeepCopyInto(&out.Conditions[i])
		}
	}
}

// ============================================================================
// BrowserSession
// ============================================================================

func (in *BrowserSession) DeepCopyInto(out *BrowserSession) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *BrowserSession) DeepCopy() *BrowserSession {
	if in == nil { return nil }
	out := new(BrowserSession)
	in.DeepCopyInto(out)
	return out
}

func (in *BrowserSession) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *BrowserSessionList) DeepCopyInto(out *BrowserSessionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]BrowserSession, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *BrowserSessionList) DeepCopy() *BrowserSessionList {
	if in == nil { return nil }
	out := new(BrowserSessionList)
	in.DeepCopyInto(out)
	return out
}

func (in *BrowserSessionList) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *BrowserSessionSpec) DeepCopyInto(out *BrowserSessionSpec) {
	*out = *in
	if in.Viewport != nil {
		out.Viewport = new(Viewport)
		*out.Viewport = *in.Viewport
	}
	if in.LaunchParams != nil {
		out.LaunchParams = new(LaunchParams)
		in.LaunchParams.DeepCopyInto(out.LaunchParams)
	}
}

func (in *BrowserSessionStatus) DeepCopyInto(out *BrowserSessionStatus) {
	*out = *in
	if in.State != nil {
		out.State = new(SessionStateSnapshot)
		*out.State = *in.State
	}
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		for i := range in.Conditions {
			in.Conditions[i].DeepCopyInto(&out.Conditions[i])
		}
	}
}

func (in *LaunchParams) DeepCopyInto(out *LaunchParams) {
	*out = *in
	if in.Headless != nil {
		out.Headless = new(bool)
		*out.Headless = *in.Headless
	}
	if in.Args != nil {
		out.Args = make([]string, len(in.Args))
		copy(out.Args, in.Args)
	}
	if in.IgnoreDefaultArgs != nil {
		out.IgnoreDefaultArgs = make([]string, len(in.IgnoreDefaultArgs))
		copy(out.IgnoreDefaultArgs, in.IgnoreDefaultArgs)
	}
}

// ============================================================================
// AutomationTask
// ============================================================================

func (in *AutomationTask) DeepCopyInto(out *AutomationTask) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *AutomationTask) DeepCopy() *AutomationTask {
	if in == nil { return nil }
	out := new(AutomationTask)
	in.DeepCopyInto(out)
	return out
}

func (in *AutomationTask) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *AutomationTaskList) DeepCopyInto(out *AutomationTaskList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]AutomationTask, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *AutomationTaskList) DeepCopy() *AutomationTaskList {
	if in == nil { return nil }
	out := new(AutomationTaskList)
	in.DeepCopyInto(out)
	return out
}

func (in *AutomationTaskList) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *AutomationTaskSpec) DeepCopyInto(out *AutomationTaskSpec) {
	*out = *in
	if in.Input != nil {
		out.Input = make(map[string]interface{}, len(in.Input))
		for k, v := range in.Input {
			out.Input[k] = v
		}
	}
	if in.Actions != nil {
		out.Actions = make([]ActionSpec, len(in.Actions))
		for i := range in.Actions {
			in.Actions[i].DeepCopyInto(&out.Actions[i])
		}
	}
	if in.CustomIdleProfile != nil {
		out.CustomIdleProfile = new(IdleProfileSpec)
		in.CustomIdleProfile.DeepCopyInto(out.CustomIdleProfile)
	}
	if in.RetryPolicy != nil {
		out.RetryPolicy = new(RetryPolicySpec)
		in.RetryPolicy.DeepCopyInto(out.RetryPolicy)
	}
}

func (in *AutomationTaskStatus) DeepCopyInto(out *AutomationTaskStatus) {
	*out = *in
	if in.CurrentAction != nil {
		out.CurrentAction = new(ActionProgress)
		*out.CurrentAction = *in.CurrentAction
	}
	if in.Metrics != nil {
		out.Metrics = new(TaskMetricsStatus)
		*out.Metrics = *in.Metrics
	}
	if in.Output != nil {
		out.Output = make(map[string]interface{}, len(in.Output))
		for k, v := range in.Output {
			out.Output[k] = v
		}
	}
	if in.Error != nil {
		out.Error = new(TaskErrorStatus)
		in.Error.DeepCopyInto(out.Error)
	}
	if in.ActionLog != nil {
		out.ActionLog = make([]ActionResult, len(in.ActionLog))
		for i := range in.ActionLog {
			in.ActionLog[i].DeepCopyInto(&out.ActionLog[i])
		}
	}
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		for i := range in.Conditions {
			in.Conditions[i].DeepCopyInto(&out.Conditions[i])
		}
	}
}

// ============================================================================
// TaskRecord
// ============================================================================

func (in *TaskRecord) DeepCopyInto(out *TaskRecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *TaskRecord) DeepCopy() *TaskRecord {
	if in == nil { return nil }
	out := new(TaskRecord)
	in.DeepCopyInto(out)
	return out
}

func (in *TaskRecord) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *TaskRecordList) DeepCopyInto(out *TaskRecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]TaskRecord, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *TaskRecordList) DeepCopy() *TaskRecordList {
	if in == nil { return nil }
	out := new(TaskRecordList)
	in.DeepCopyInto(out)
	return out
}

func (in *TaskRecordList) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

func (in *TaskRecordSpec) DeepCopyInto(out *TaskRecordSpec) {
	*out = *in
	if in.Input != nil {
		out.Input = make(map[string]interface{}, len(in.Input))
		for k, v := range in.Input {
			out.Input[k] = v
		}
	}
	if in.Actions != nil {
		out.Actions = make([]ActionRecord, len(in.Actions))
		for i := range in.Actions {
			in.Actions[i].DeepCopyInto(&out.Actions[i])
		}
	}
	in.Result.DeepCopyInto(&out.Result)
}

// ============================================================================
// Shared Sub-Type DeepCopy
// ============================================================================

func (in *ActionSpec) DeepCopyInto(out *ActionSpec) {
	*out = *in
	if in.Target != nil {
		out.Target = new(ActionTarget)
		in.Target.DeepCopyInto(out.Target)
	}
	if in.Params != nil {
		out.Params = new(ActionParams)
		in.Params.DeepCopyInto(out.Params)
	}
	if in.Assertion != nil {
		out.Assertion = new(ActionAssertion)
		*out.Assertion = *in.Assertion
	}
	if in.IdleOverride != nil {
		out.IdleOverride = new(IdleOverride)
		in.IdleOverride.DeepCopyInto(out.IdleOverride)
	}
}

func (in *ActionTarget) DeepCopyInto(out *ActionTarget) {
	*out = *in
	if in.Coordinates != nil {
		out.Coordinates = new(Coordinate)
		*out.Coordinates = *in.Coordinates
	}
}

func (in *ActionParams) DeepCopyInto(out *ActionParams) {
	*out = *in
	if in.Values != nil {
		out.Values = make([]string, len(in.Values))
		copy(out.Values, in.Values)
	}
	if in.Args != nil {
		out.Args = make([]string, len(in.Args))
		copy(out.Args, in.Args)
	}
}

func (in *IdleProfileSpec) DeepCopyInto(out *IdleProfileSpec) {
	*out = *in
	if in.BaseIdle != nil { out.BaseIdle = new(Range); *out.BaseIdle = *in.BaseIdle }
	if in.AfterNavigation != nil { out.AfterNavigation = new(Range); *out.AfterNavigation = *in.AfterNavigation }
	if in.AfterClick != nil { out.AfterClick = new(Range); *out.AfterClick = *in.AfterClick }
	if in.AfterType != nil { out.AfterType = new(Range); *out.AfterType = *in.AfterType }
	if in.AfterScroll != nil { out.AfterScroll = new(Range); *out.AfterScroll = *in.AfterScroll }
	if in.BeforeSubmit != nil { out.BeforeSubmit = new(Range); *out.BeforeSubmit = *in.BeforeSubmit }
	if in.DecisionTime != nil { out.DecisionTime = new(Range); *out.DecisionTime = *in.DecisionTime }
	if in.DistractionDur != nil { out.DistractionDur = new(Range); *out.DistractionDur = *in.DistractionDur }
}

func (in *IdleOverride) DeepCopyInto(out *IdleOverride) {
	*out = *in
	if in.BaseIdle != nil { out.BaseIdle = new(Range); *out.BaseIdle = *in.BaseIdle }
	if in.BeforeSubmit != nil { out.BeforeSubmit = new(Range); *out.BeforeSubmit = *in.BeforeSubmit }
}

func (in *RetryPolicySpec) DeepCopyInto(out *RetryPolicySpec) {
	*out = *in
	if in.RetryableErrors != nil {
		out.RetryableErrors = make([]string, len(in.RetryableErrors))
		copy(out.RetryableErrors, in.RetryableErrors)
	}
}

func (in *TaskErrorStatus) DeepCopyInto(out *TaskErrorStatus) {
	*out = *in
	if in.ActionIndex != nil {
		out.ActionIndex = new(int)
		*out.ActionIndex = *in.ActionIndex
	}
}

func (in *ActionResult) DeepCopyInto(out *ActionResult) {
	*out = *in
	if in.ExtractedValue != nil {
		out.ExtractedValue = make(map[string]interface{}, len(in.ExtractedValue))
		for k, v := range in.ExtractedValue {
			out.ExtractedValue[k] = v
		}
	}
}

func (in *ActionRecord) DeepCopyInto(out *ActionRecord) {
	*out = *in
	if in.Target != nil {
		out.Target = new(ActionTarget)
		in.Target.DeepCopyInto(out.Target)
	}
	if in.Params != nil {
		out.Params = new(ActionParams)
		in.Params.DeepCopyInto(out.Params)
	}
	in.Result.DeepCopyInto(&out.Result)
}

func (in *TaskResultRecord) DeepCopyInto(out *TaskResultRecord) {
	*out = *in
	if in.Output != nil {
		out.Output = make(map[string]interface{}, len(in.Output))
		for k, v := range in.Output {
			out.Output[k] = v
		}
	}
	if in.Error != nil {
		out.Error = new(TaskErrorStatus)
		in.Error.DeepCopyInto(out.Error)
	}
}
